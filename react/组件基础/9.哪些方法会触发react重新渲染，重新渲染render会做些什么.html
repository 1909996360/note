<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>哪些方法会触发react重新渲染？重新渲染render会做些什么？</title>
</head>
<body>
    <script>
        /*
            （1）哪些方法会触发react重新渲染
              · setState（）方法被调用
              setState是react中最常用的命令，通常情况下，执行setState会触发render,但是这里有个点值得关注，执行setState的时候不一定会重新渲染，当setSate传入null时，并不会触发render

            class App extends React.Component {
                state = {
                    a: 1
                };

                render() {
                    console.log("render");
                    return (
                    <React.Fragement>
                        <p>{this.state.a}</p>
                        <button
                        onClick={() => {
                            this.setState({ a: 1 }); // 这里并没有改变 a 的值
                        }}
                        >
                        Click me
                        </button>
                        <button onClick={() => this.setState(null)}>setState null</button>
                        <Child />
                    </React.Fragement>
                    );
                }
             }

             · 父组件重新渲染
                只要父组件重新渲染了，即使传入子组件的props未发生变化，那么子组件也会重新渲染，进而触发render


             （2）重新渲染render会做些什么
                · 会对比新旧VNode进行对比，也就是我们所说的Diff算法
                · 对新旧两棵树进行一个深度优先遍历，这样每一个节点都会一个标记，再到深度遍历的时候，每遍历到一个节点，就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面
                · 遍历差异对象，根据差异的类型，根据对应规则更新VNode

            React的处理render的基本思维模式是每次一有变动就会重新渲染整个应用，在Virtual DOM没有出现之前，最简单的方法就是直接调用inner HTML，Virtual DOM厉害的地方并不是说它比直接操作DOM快，而是说不管数据怎么变，都会尽量以最小的代价去更新DOM。React将render函数返回的虚拟DOM树与老的进行比较，从而确定DOM要不要更新，怎么更新。当DOM树很大时，遍历两棵树及进行各种对比还是相当耗性能的，特别是在顶层setState一个微小的修改，默认会去遍历整棵树，尽管React使用高度优化的Diff算法，但是这个过程仍然会损耗性能
        */ 
    </script>
</body>
</html>