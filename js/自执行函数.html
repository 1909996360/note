<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>自执行函数</title>
</head>
<body>
    <script>
        //普通函数定义和调用
        // function add(a,b){
        //     return sum = a + b
        // }
        // var aa = add(1,2)
        // console.log(aa);

        // 自执行函数

        // 1、写法1
        // (function aa(a,b){
        //     return sum = a+b,console.log(sum);
        // })(1,2)


        //2、写法2
        // (function bb(a,b){
        //     return sum1 = a + b ,console.log(sum1);
        // }(1,2))

        // 3、写法3
        // !function cc(a,b){
        //     return sum = a+b,console.log(sum);
        // }(1,2)


        // 保持闭包的状态
        // 就像当函数通过他们的名字被调用时，参数会被传递，而当函数表达式被立即调用时，参数也会被传递。一个立即调用的函数表达式可以用来锁定值并且有效的保存此时的状态，因为任何定义在一个函数内的函数都可以使用外面函数传递进来的参数和变量（这种关系叫做闭包）

        // var elems = document.getElementsByTagName('a')
        // for(var i = 0;i<elems.length;i++){
        //     elems[i].addEventListener('click',function(e){
        //         e.preventDefault()
        //         alert('i am link #'+i)

        //     },false)
        // }

        // 而像下面这样改写，便可以了，因为在IIFE里，'i'值被锁定在了'lockedInIndex'里，
        // 在循环结束执行时，尽管'i'值的数值是所有元素的总和，但每一次函数表达式被调用时，
        // IIFE里的'lockedInIndex'值都是'i'传给他的值，所以当链接被点击时，正确的值被弹出
        // var elems = document.getElementsByTagName('a')
        // for(var  i = 0 ; i<elems.length;i++){
        //     (function(lockedInIndex){
        //         elems[i].addEventListener('click',function(e){
        //             e.preventDefault()
        //             alert('I am link #'+lockedInIndex)
        //         },false)
        //     })(i)
        // }


        // 最后：模块模式
        // 当我调用函数表达式时，如果我不至少一次的提醒我自己关于模块模式，我便很可能会忽略它，如果你并不属于JavaScript里的模块模式，使用返回值用对象代替了函数
        var counter = (function(){
            var i = 0
            return {
                get:function(){
                    return i 
                },
                set:function(val){
                   i = val
                },
                increment:function(){
                    return ++i
                }
            }
        }())
        console.log(counter.get()); // 0
        console.log(counter.set(3)); // 3
        console.log(counter.increment()); //4
        console.log(counter.increment()); //5
    </script>
</body>
</html>