<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>前端性能优化总结</title>
</head>
<body>
    <script>
    /*
        1、减少http请求
            一个完整的http请求需要经历DNS查找、TCP握手，浏览器发出HTTP请求，服务器接收请求，服务器处理请求并发回响应，浏览器接收相应等过程。建立连接和下载数据都需要时间，应尽量将多个小文件合并成一个大文件，从而减少HTTP请求次数

        2、将CSS放在文件头部，JavaScript文件放在底部
             所有放在head标签里的css和js文件都会堵塞渲染（css不会阻塞DOM解析）。如果这些css和js需要加载和解析很久的话，那么页面就空白了。所以js文件要放在底部，等HTML解析完了再加载js文件

        ？？那为什么css文件还要放在头部呢

            因为先加载HTML再加载CSS，会让用户第一时间看到的页面是没有样式的、为了避免这种情况发生，就要将css文件放在头部了

            另外，js文件也不是不可以放在头部，只要给script标签加上defer属性就可以了，异步下载，延迟执行

        3、减少重绘重排
            浏览器渲染过程：
                (1)解析HTML生成DOM树
                (2)解析CSS生成CSSOM规则树
                (3)解析JS，操作DOM树和CSSOM规则树
                (4)将DOM树与CSSOM树合并在一起生成渲染树
                (5)遍历渲染树开始布局，计算每个节点的位置大小信息
                (6)浏览器将所有图层的数据发送给GPU，GPU将图层合成并显示在屏幕上

            重排：元素位置和尺寸发生改变、DOM元素的增删、添加行内样式、浏览器窗口发生改变、页面首次渲染，元素相对于文档定位改变时会导致浏览器重新生成渲染树，这个过程叫重排。

            重绘：当重新生成渲染树后，会将渲染树每个节点绘制到屏幕，这个过程叫做重绘。颜色改变、背景图片改变，只要不影响元素相对于浏览器文档位置的改变，就会导致重绘

        ？？如果减少重排重绘？

            减少DOM操作、避免使用行内样式、修改DOM节点的多条语句合并成一条语句来执行
        
        4、图片优化
            (1)图片延迟加载
                在页面中，先不给图片设置路径，只有当图片出现在浏览器的可视区域时，才去加载真正的图片，这就是延迟加载，即懒加载
            (2)使用字体图标iconfont代替图片图标
                字体图标就是将图标制作成一个字体，使用时就跟字体一样，可设置属性，例如font-size、color等等，非常方便，并且字体图标是矢量图，不会失真。并且生成的文件特别小
            (3)使用精灵图
                所谓精灵图就是把很多的小图片合并到一张较大的图片里，所以在首次加载页面的时候，就不用加载过多的小图片，只需要加载出来将小图片合并起来的那一张大图片也就是精灵图即可，这样在一定程度上减少了页面的加载速度，也一定程度上缓解了服务器的压力。
                使用：
                    将精灵图设为一个大背景，然后通过background-position来移动背景图，从而显示出我们想要显示出来的部分。
                缺点：
                    图片的背景都是我们详细测量而得出来的，当需要改动页面，会很麻烦

            (4)尽可能使用css3效果代替图片
                有很多图片使用CSS效果（渐变、阴影等）就能画出来，这种情况选择CSS3效果更好，因为代码大小通常是图片大小的几分之一甚至几十分之一
            (5)使用webp格式的图片
                WebP的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha透明以及动画的特性，在JPEG和PNG上的转化效果都相当优秀、稳定和统一
        
        5、压缩文件
            压缩文件可以减少文件下载时间，让用户体验性更好
            gzip是目前最流行和最有效的压缩方法，可以通过向HTTP请求头中的Accept-Encoding头添加gzip标识来开启这一功能
            在webpack可以使用如下插件进行压缩
            ·javascript：UglifyPlugin
            ·CSS：MiniCssExtractPlugin
            ·HTML:HtmlWebpackPlugin

        6、善用缓存，不重复加载相同资源
            为了避免用户每次访问网站都得请求文件，我们可以通过添加Expires或max-age来控制这一行为。Expires设置了一个时间，只要在这个时间之间，浏览器都不会请求文件，而是直接使用缓存。而max-age是一个相对时间，建议使用max-age代替Expires。这里又涉及HTTP缓存的知识 -- 强缓存和协商缓存

        7、使用事件代理
            事件代理（委托）：把原本需要绑定在子元素的响应事件委托给父元素，让父元素担任事件监听的职务，原理是DOM元素的事件冒泡。
            优点：
                节省内存空间，减少事件注册（比如鼠标事件和键盘事件，ul代理所有li的click事件，新增元素时无需再次对其进行事件绑定）

        8、静态资源使用CDN
            内容分发网络（CDN）是一组分布在多个不同地理位置的web服务器，这些服务器存储着数据的副本，因此服务器会根据哪些服务器离用户距离最近来满足数据的请求。CDN的两个核心点：
            ·缓存：就是指我们把资源复制一份到CDN服务器的这个过程
            ·回溯：指CDN发现自己没有这个资源（一般是缓存的数据过期了），转头向根服务器（或者上级服务器）去找资源的这个过程
        
        9、使用服务器端渲染
            客户端渲染：获取HTML文件，根据需要下载JavaScript文件，运行文件，生成DOM，再渲染。
            服务端渲染：服务端返回HTML文件，客户端只需解析HTML
                ·优点：首屏渲染快，SEO好
                ·缺点：配置麻烦，增加了服务器的计算压力
            区别：
                客户端渲染的网站是直接返回HTML文件，而服务端渲染的网站是渲染完页面再返回这个HTML文件，Vue的ssr就是服务端渲染

        10、webpack按需加载代码
            懒加载或者按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载
            在webpack项目中，有一个入口文件，相当于一棵树的主干，入口文件有很多依赖的模块，相当于树枝。实际情况中，虽然依赖了某个模块，但其实只使用其中的某些功能。通过tree-shaking，将没有使用的模块摇掉，这样来达到删除无用代码的目的

        11、使用Web Workers
            Web Worker 使用其他工作线程从而独立于主线程之外，它可以执行任务而不干扰用户界面，一个worker可以将消息发送到创建它的JavaScript代码，通过将消息发送到该代码指定的事件处理程序
            Web Worker 适用于那些纯数据，或者与浏览器ui无关的长时间运行脚本
    */    
    </script>
</body>
</html>