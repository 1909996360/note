<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>正则表达式</title>
</head>
<body>
    <script>
        /*

            正则中的括号()、中括号[]、花括号{}的区别
            正则表达式的()、[]、{}有不同的意思
            ()是为了提取匹配的字符串。表达式中有几个()就有几个相应的匹配字符串
            (\s*)表示连续空格的字符串
            []是定义匹配的字符范围。比如[a-zA-Z0-9]表示相应位置的字符要匹配英文字符和数字。[\s*]表示空格或者*号
            {}一般用来表示匹配的长度，比如\s[3]表示匹配三个空格，\s[1,3]表示匹配一到三个空格
            
            (0-9)匹配'0-9'本身。
            [0-9]*匹配数字（注意后面有*,可以为空）
            [0-9]+匹配数字（注意后面有+，不可以为空）
            [1-9]写法错误
            [0-9]{0-9}表示长度为0到9的数字字符串

            圆括号()是组，主要应用在限制多选结构的范围/分组/捕获文本/环视/特殊模式处理
            示例：
                1、(abc|bcd|cde)，表示这一段是abc、bcd、cde三者之一均可，顺序也必须一致
                2、(abc)? 表示这一组要么一起出现，要么不出现，出现则按词组内的顺序出现
                3、(?:abc) 表示找到这样abc这样一组，但不记录，不保存到$变量中，否则可以通过$x取第几个括号所匹配到的项，比如：(aaa)(bbb)(ccc)(?:ddd)(eee)，可以用$1获取(aaa)匹配到的内容，而$4则获取的是由(eee)匹配到的内容，因为前一对括号没有保存变量
                4、a(?=bbb)顺序环视，表示a后面必须紧跟3个连续的b
                5、(?i:xxxx)不区分大小写 (?s:.*)跨行匹配，可以匹配回车符

            方括号是单个匹配，字符集/排除字符集/命名字符集
            示例：
                1、[0,3]表示找到这一个位置上的字符只能是0到3这四个数字，与(abc|bcd|cde)的作用比较类似，但圆括号可以匹配多个连续的字符，而一对方括号只能匹配单个字符
                2、[^0-3]表示找到这一个位置上的字符只能是除了0到3之外的所有字符
                3、[:digit:]0-9[:alnum]: A-Za-z0-9
            
            ()和[]有本质的区别
            ()内的内容表示的是一个子表达式，()本身不匹配任何东西，也不限制匹配任何东西，只是把括号内的内容作为一个表达式来处理，例如(ab){1,3}，就表示ab一起连续出现最少1次，最多3次。如果没有括号的话，ab{1,3}就表示a，后面紧跟的b出现出少1次，最多3次。另外，括号在匹配模式中也很重要，这个就不延伸了

            []表示匹配的字符在[]中，并且只能出现一次，并且特殊字符写在[]会被当成普通字符来匹配。例如[(a)],会匹配(、a、)这三个字符




            1、正则中常用来表示位置的符号主要有：
            ^、$、\b、\B、?=p 、(?!p)、(?<=p) 、(?<!p)

            ^:脱字符，匹配行的开头
                例如要在hello的开头塞一个字符
                let string = 'hello'
                console.log(string.replace(/^/,'s')) //shello

            $:美元符号，匹配行的结尾
                同理想在hello的结尾塞一个s呢
                 let string = 'hello'
                 console.log(string.replace(/$/,'w')); //hellow

            \b:单词的边界，具体讲有三点规则
                1、\w和\W之间的位置
                2、^与\w之间的位置
                3、\w与$之间的位置

                'xxx_love_study_1.mp4'.replace(/\b/g, '❤️') //❤️xxx_love_study_1❤️.❤️mp4❤️

            \B:非单词的边界，也就是\b反着来的意思，他的规则如下：
                1、\w和\W之间的位置
                2、\W和\W之间的位置
                3、^和\W之间的位置
                3、\W和$之间的位置
                '[[xxx_love_study_1.mp4]]'.replace(/\B/g, '❤️')
                //❤️[❤️[x❤️x❤️x❤️_❤️l❤️o❤️v❤️e❤️_❤️s❤️t❤️u❤️d❤️y❤️_❤️1.m❤️p❤️4]❤️]❤️

            (?=p):符合p子模式前面的那个位置。换句话说是，有一个位置，紧跟其后需要满足p子模式，也有一个学名叫正向先行断言
                利用(?=p)就可以很方便这件事
                'xxx_love_study_1.mp4'.replace(/(?=xxx)/g, '❤️') // ❤️xxx_love_study_1.mp4

            (?!p):反过来的意思，可以理解为(?=p)匹配到的位置之外的位置都是属于(?!p)的，它也有一个学名叫负向先行断言
                'xxx_love_study_1.mp4'.replace(/(?!xxx)/g, '❤️') //x❤️x❤️x❤️_❤️l❤️o❤️v❤️e❤️_❤️s❤️t❤️u❤️d❤️y❤️_❤️1❤️.❤️m❤️p❤️4❤️

            (?<=p):符合p子模式后面(注意(?=p)表示的是前面)的那个位置，换句话说是，有一个位置，其前面的部分需要满足p子模式
                'xxx_love_study_1.mp4'.replace(/(?<=xxx)/g, '❤️') //xxx❤️_love_study_1.mp4

            (?<!p):反过来的意思，可以理解为(?<=p)匹配到的位置之外的位置都是属于(?<!p)的
                'xxx_love_study_1.mp4'.replace(/(?<!xxx)/g, '❤️') //
                ❤️x❤️x❤️x_❤️l❤️o❤️v❤️e❤️_❤️s❤️t❤️u❤️d❤️y❤️_❤️1❤️.❤️m❤️p❤️4❤️

            // 例子详解：学习完位置相关的知识，我们来做一下开头的几个题目试试

            // 题目1：数字的千分位分割法
                将123456789转化为123，456，789
                观察题目的规律就是从后往前，每三个数字加一个逗号（需要注意的是开头不需要加逗号）。是不是很符合(?=p)的规律呢？p可以表示每三个数字，要添加的逗号所处的位置正好是(?=p)匹配出来的位置
                1、第一步，尝试先把后面第一个都好弄出来
                let price = '123456789'
                let priceReg = /(?=\d{3}$)/

                2、第二步，把所有的逗号都弄出来
                要把所有的逗号都弄出来，主要是解决的问题是怎么表示三个数字一组，也就是3的倍数，我们知道正则中括号可以把一个p模式变成一个小整体，所以利用括号的性质，可以这样写

                let price = '123456789'
                let priceReg = /(?=(\d{3}+$))/g

                3、第三步，去掉首位的逗号
                上面已经基本上实现了需求了，但是还不够，首位会出现，那怎么把首位的逗号去除呢？想想前面是不是有一个知识正好满足这个场景？没错(?!p)，就是它，晾着结合就是从后往前每三个数字的位置前添加逗号，但是这个位置不能是^首位
                let price = '123456789'
                let priceReg = /(?!^)(?=(\d{3})+$)/g

            // 题目2：手机号3-4-4分割
                将手机号转化为xxx-xxxx-xxxx
                有了上面数字的千分位分割法，做这个题相信会简单很多，也就是从后往前找到这样的位置：
                每四个数字前的位置，并把这个位置替换为-
                let mobile = '15813228684'
                let mobileReg = /(?=(\d{4})+$)/g

            // 题目3：手机号3-4-4分割扩展
                将手机号11位以内的数字转化成3-4-4格式
                回想一下这样的场景，有一个表单需要手机用户的手机号，用户是一个个数字输入的，我们需要在用户输入11位手机号的过程中把其转化为3-4-4格式，即
                xxx-xxxx-xxxx
                这样用(?=p)就不太合适了，例如1234就会变成-1234.用(?<=p)

                第一步，将第一个 - 弄出来
                const formatMobile = (mobile) =>{
                    return String(mobile).replace(/(?<=\d{3})\d+/,'-')
                }

                第二部，将第二个 - 弄出来
                将第一个-弄出来以后，字符的长度多了一位，原本1234567（这个位置插入-）8，要变成往后移一位
                const formatMobile = (mobile) =>{
                    return String(mobile).slice(0,11).replace(/(?<=\d{3})\d+/,($0) =>'-'+$0).replace(/(?<=[\d-]{8})\d{1,4}/,($0) => '-' + $0)
                }

            // 题目4：验证密码的合法性
                密码长度是6-12位，由数字、小写字符和大写字母组成，但必须至少包括两种字符
                题目由三个条件组成
                1、密码长度是6-12位
                2、由数字、小写字符和大写字母组成
                3、必须至少包括2种字符

                第一步，写出条件1和条件2的正则
                let reg = /^[a-zA-Z\d]{6,12}$/
                第二步，必须包含某种字符（数字、小写字母、大写字母）
                let reg = /(?=.*\d)/
                // 这个正则的意思是：匹配的是一个位置，这个位置需要满足`任意数量的符号，紧跟着是个数字`，注意它最终得到的是个位置，而不是数字或者是数字前面有任意的东西`
                console.log(reg.test('hello')) //false
                console.log(reg.test('hello1')) //true
                console.log(reg.test('hello2')) //true
                第三步，写出完整的正则
                必须包含两种字符，有下面四种排列组合方式
                1、数字和小写字母组合
                2、数字和大写字母组合
                3、小写字母与大写字母组合
                4、数字、小写字母、大写字母一起组合（但其实前面三种已经覆盖了第四种了）
                表示条件1和条件2
                let reg = /((?=.*\d)((?=.*[a-z])|(?=.*[A-Z])))/
                表示条件3
                let reg = /(?=.*[a-z])(?=.*[A-Z])/
                表示条件123
                let reg = /((?=.*\d)((?=.*[a-z])|(?=.*[A-Z])))|(?=.*[a-z])(?=.*[A-Z])/
                表示题目所有条件
                let reg = /((?=.*\d)((?=.*[a-z])|(?=.*[A-Z])))|(?=.*[a-z])(?=.*[A-Z])^[a-zA-Z\d]{6,12}$/

            2、字符串匹配原来这么简单
                ·两种模糊匹配
                    正则如果只有精确匹配，那么便完全没有了意义
                       （1）横向
                        一个正则可匹配的字符串的长度不是固定的，可以是多种情况，通过量词+、*、?、{m,n}，可实现横向匹配
                        let reg = /ab{2,5}c/
                        let str = 'abc abbc abbbc abbbbc abbbbbbc abbbbbbc'
                        str.match(reg) //['abbc','abbbc','abbbbc','abbbbbc']
                        (2)纵向
                        一个正则匹配的字符串，具体到某一位字符时，可以不是某个确定的字符串，可以有多种可能，实现方式是字符组（其实多选分支|也可以实现）
                        let reg = /a[123]c/
                        let str = 'a0b a1b a2b a3b a4b'
                        str.match(reg) // ['a1b','a2b','a3b']
                ·字符组
                    不要被名字给糊弄了，虽然他叫做字符组，但其实只是代表一个字符的可能性
                        （1）范围表示法
                        [123456abcdefABCDEF] => [1-6a-fA-F]
                        （2）排除字符组
                        某位字符可以是任何东西，但是就是不能是xxx，使用^符号
                        问题：如何要表示除了某个单词以外的任意东西呢
                        [^abc]
                ·常见简写形式
                    \d //数字
                    \D //非数字
                    \w //[0-9a-zA-Z_]
                    \W //[^0-9a-zA=Z_]
                    \s //[\t\v\n\r\f]
                    \S //[^\t\v\n\r\f]

                ·量词
                    1.{m,} //至少出现m次
                    2.{m} //出现m次
                    3.?   //出现0次或者1次，等价于{0,1}
                    4.+   //至少出现1次，等价于{1,}
                    5.*   //出现任一次，等价于{]0,}

                ·贪婪匹配vs惰性匹配
                    正则本身是贪婪的，会尽可能的多匹配符合模式的字符
                    let regex = /\d{2,5}/g
                    let string = '123 1234 12345 123456'
                    // 贪婪匹配
                    string.match(regex)

                    // 惰性匹配
                    let regex2 = /\d{2,5}?/g
                    string.match(regex2) // [12,12,34,12,34,12,34,56]

                    // 量词后面加一个?,即变成了惰性匹配
                    贪婪量词    惰性量词
                    {m,n}       {m,n}?
                    {m,}        {m,}?
                    ?               ??
                    +               +?
                    *               *?

                ·多选分支
                    一个模式可以实现横向和纵向的模糊匹配，而多选分支可以支持多个子模式任选其一，形式是(p1|p2|p3)
                    let regex = /good|nice/
                    let string = 'good idea , nice try'

                    string.match(regex) // ['good','nice']
                    // 注意，用/good|goodbye/去匹配'goodbye',匹配到的是good
                    // 因为分支结构是惰性的，前面的匹配上了，后面的就不再尝试了
                ·案例分析
                    1、匹配id
                        // 1
                        let regex = /id=".*?"/ //想想为什么要加？ 不加的话 连后面的class都会匹配到
                        let string = '<div id="container" class="main"></div>'
                        console.log(string.match(regex)[0])
                        // 2
                        let regex = /id="[^"]*"/
                        let string = '<div id="container" class="main"></div>'
                        console.log(string.match(regex)[0])
        */ 

        let string = 'hello'
        console.log(string.replace(/^/,'s'));
        console.log(string.replace(/$/,'w')); //hellow
        console.log('xxx,love,study_1,mp4'.replace(/\b/g, '❤️'));
        console.log('[[xxx,love,study_1,mp4]]'.replace(/\B/g, '❤️'));
        console.log('xxx_love_study_1.mp4'.replace(/(?=study)/g, '❤️'));
        console.log('xxx_love_study_1.mp4'.replace(/(?!love)/g, '❤️'));
        console.log('xxx_love_study_1.mp4'.replace(/(?<=xxx)/g, '❤️'));
        console.log('xxx_love_study_1.mp4'.replace(/(?<!xxx)/g, '❤️'));


        let price = '123456789'
        let priceReg = /(?=\d{3}$)/
        let priceReg2 = /(?=(\d{3})+$)/g
        let priceReg3 = /(?!^)(?=(\d{3})+$)/g
        console.log(price.replace(priceReg,',')); //123456,789
        console.log(price.replace(priceReg2,','));//,123,456,789
        console.log(price.replace(priceReg3,',')); // 123,456,789

        let mobile = '15813228684'
        let mobileReg = /(?=(\d{4})+$)/g
        console.log(mobile.replace(mobileReg,'-')); //15813228684


    </script>
</body>
</html>